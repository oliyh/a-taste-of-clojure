<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>A taste of Clojure</title>
    <meta name="author" content="Oliver Hine">
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-species-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

    <link rel="stylesheet" href="css/main.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section data-background-image="img/data-universe.jpg" style="">
          <br/><br/>
          <h1 class="title">A taste of Clojure</h1>
          <p style="color: black;">Oliver Hine</p>

          <div style="text-align: center; vertical-align: bottom; bottom: 0;">
            <a style="color: black" class="github" target="_blank" href="https://github.com/oliyh">
              <img class="logo" src="img/github-black.png"/>
              oliyh
            </a>
          </div>
          <aside class="notes">
            Hello, I'm Oliver Hine
            I'm going to talk about a functional lisp called Clojure and why you should be interested in it
          </aside>
        </section>

				<section data-background-image="img/about-me.jpg" style="">
          <h2>How my journey began</h2>
          <aside class="notes">
            I started my career as a Java developer by default - all the jobs going at the time were in Java and I'd picked up a bit at university although I had some self-taught knowledge of ASP, PHP, Javascript and the like.
            After moving through several teams, inheriting codebases of various ages and in various states I settled into a team that was "agile", did "TDD", "XP" and everything else where I learned vast amounts about proper software craftmanship and was very happy there for several years refactoring my way through tens of thousands of lines of carefully extracted interfaces, thoughtfully devised abstractions and meticulously complete stubs for mocked tests.
            We had some discussions about how Java's inheritance model didn't really let us express what we wanted to do, which at the time was something more akin to traits but I never seriously considered that rewriting the beast in a language with more features was possible.
            Fortunately a more enlightened team member introduced us to Clojure - this was around 2012 - and suddenly I had a totally different perspective on programming which I hope to share with you now.
          </aside>
        </section>

				<section data-background-image="" style="">
          <h2>Clojure</h2><br/><br/>
          <ul>
            <li>Functional</li>
            <li>Simple, concise</li>
            <li>Immutable data</li>
          </ul>
          <aside class="notes">
            These three points are the most important things to know about Clojure.
            Number one, it's functional, meaning functions are first class. You can declare and call functions, pass functions into other functions and return functions just as you would any other piece of data.
            Two is that it is simple and concise - there is very little syntax. Calling functions and data literals is pretty much all you need which makes it quick to learn and easy to read.
            Third is that data structures are immutable and highly efficient. This means that if I have a reference to some data I can guarantee that no one else can change it while I'm using it.
            I'll come back to these later to discuss in more detail.
            They are listed here because they're not the norm for programming languages, even though we could probably agree that they're good things.
            They are also basic, fundamental things. Clojure doesn't really have any clever, complicated high level abstractions that you have to learn. Abstractions are what the programs we write should do, and trying to line up the abstractions of our programs with the abstractions of our language is often quite hard to do and can add a lot of complexity.
            Clojure is about stripping out all the complexity that comes from the language and giving you a tool that does simple, fundamental things very well.
          </aside>
        </section>

				<section style="">
          <h2>Clojure ðŸ’– JVM</h2>
          <br/><br/><br/>
          (Clojure <span class="yellow">ðŸ’–</span> Javascript too)

          <aside class="notes">
            One thing missing from the previous slide is a practical and non-functional feature of Clojure which is that it compiles to and runs on the JVM. This was a pragmatic decision made both to improve Clojure's adoption appeal to people already familiar with the JVM and because of the high performance. In addition Clojure's ability to interop with Java code means that it benefits from all the libraries in the Java ecosystem. Deployment is shipping an uberjar and running it with java -jar.

            And one thing missing from this slide is that Clojure also compiles to Javascript which is now the world's most widespread runtime, and takes it to places that we never dreamed of before. Clojure can be used in browsers and on servers which makes it amazing for full stack development.
          </aside>
        </section>

				<section style="">
          <h2>Tooling</h2><br/>
          <ul>
            <li>Two build tools, lein and boot</li>
            <li>All major IDEs</li>
          </ul>
          <br/>
          <img src="img/xkcd-lisp.jpg"/>

          <aside class="notes">
            There are now two build tools, after many years with just one, that take care of all your dependencies, versioning, run profiles and everything else. They're both implemented in Clojure so understanding them, extending and changing them is quite easy.

            You can write Clojure with great editor support in Intellij, emacs, Eclipse and vim.
            Some tools which really help are paredit for emacs which abstracts away all the parentheses into operations on s-expressions. I know they can be intimidating at first but after getting used to them and the naked structure of lisp unfolds before you, the patterns and metapatterns dance and you swim in the purity of quantified conception of ideas manifest.
          </aside>
        </section>

				<section style="">
          <h2>REPL</h2><br/>

          Video of stuff happening in a repl here, in case it all goes wrong, but
          consider live coding as well

          <aside class="notes">
            The REPL is a live coding environment where you can evaluate any expression. REPL stands for Read, Evaluate, Print, Loop and is not unique to Clojure but to Lisps in general and even a command line interface can be thought of in the same way.

            It allows you to jump straight into using Clojure without having to understand how an entire program fits together or anything else, so it's great to get started with but there is a much greater impact of having this tool at your disposal.

            The IDEs I mentioned earlier integrate with a REPL environment and allow you to live-evaluation code in your IDE. You can hotload changes in source code into the REPL and it becomes a live playground for building, trying and testing code.

            It encourages exploration and less reliance on the test scaffolding we might otherwise normally write as part of dogmatic TDD

          </aside>
        </section>

				<section style="">
          <h2>Functional, Simple</h2><br/>
          <pre><code class="hljs" data-trim>
(defn doubles [x]
  (* x 2))

(defn sequence-that [f]
  (map f (range 5)))

(sequence-that doubles)
;; => 0 2 4 6 8
          </code></pre>
          <pre><code class="hljs" data-trim>
(defn squares [x]
  (* x x))

(sequence-that (comp squares doubles))
;; => 0 4 16 36 64
          </code></pre>
          <aside class="notes">
            Functional languages treat functions as first class citizens that can be referred to in the same way as everything else, allowing them to be passed around, called, closed over. Of course, you can achieve similar-looking code in a non-functional language but at a far greater cost in boilerplate, lines of code and glue which all add to the cognitive weight of the project.

            When everything is stripped back to the bare definition of what it does it removes a lot of background processing from your brain, giving you a little extra capacity to focus on the task in hand. When entire concepts are removed, like static or final or overrides, you can look at a function and see what it does without worrying about constantly trying to work out if it was called on an instantiated object or is static, if the current state of the object can affect the return value, if this is the function being called or if someone has overridden it somewhere else.

            Your brain can slowly unwind and think about the problem you're actually trying to solve, to derive data from other data, and not have to fight uncertainty which has been built into the programming language you're using.

            Clojure owes its simplicity to its creator, Rich Hickey, who is a deep thinker and gave a great talk entitled Simple Made Easy explaining the rationale. Itâ€™s relatively new and designed by one person â€“ rather than being old, with a lot of legacy and backward compatability, designed by a committee.
          </aside>
        </section>

				<section style="">
          <h2>Can't touch this</h2><br/>
          <pre><code class="hljs" data-trim>
(def numbers [0 1 2 3 4])

(map doubles numbers)
;; => 0 2 4 6 8

(map squares numbers)
;; => 0 1 4 9 16
          </code></pre>
          <aside class="notes">
            All of Clojure's data types are immutable. You can do anything with them, but you can't do anything to them. Every operation on them returns new immutable data and the original is unchanged.

            Seems like a simple concept, and it is. The same concepts exists in other languages too but is rarely the default and is something you have to go out of your way to use.

            Why is this such a big deal? Because, in normal code, it guarantees thread safety. The source of some of the most difficult to solve problems is suddenly eradicated completely. It's comparable to the way the JVM's memory model suddenly eradicated the whole concept of buffer overflow bugs, bugs which still afflict us today in the guises of Heartbleed and just a couple of weeks ago Cloudflare's Cloudbleed incident.
          </aside>
        </section>


				<section>
          <pre><code class="hljs" data-trim>
              State â€“ when you need it
              Carefully managed using atoms which are thread safe

              What does all this mean?
              The net effect of not having to worry about constructing a clever and complicated type hierarchy of abstract concepts
              Become much closer to the data â€“ it becomes tangible, you can inspect it and play with it, itâ€™s not hidden away in some OO model
              Functions always return the same value given the same inputs â€“ removes a whole category of bugs (and the hardest bugs to track down as well â€“ heisenbugs)
              Unlikely to have threading bugs as well, also one of the harder kind of bugs to solve
              Full front-to-back services in the same language â€“ amazing for the developer

              How does it work without types?
              Can validate data using spec and schema at the edges of the system, leaving only happy path code inside
              Can write generative tests using these tools to test all permutations
              Linters can catch a lot of mistakes
              You tend to just deal with the primitive data types which tend to be much more compact anyway â€“ you know what sort of data you are dealing with
              You tend to write tests using real data, because itâ€™s just data that you can pull out of real systems and use immediately (rather than it being embedded in objects and abstractions which are hard to reconstruct in your test environment)
              What is the right thing to test? (comedy test the right thing gif here) - the answer is everything, and having a data-oriented language helps describe and realise this



              Whatâ€™s cool?
              Live server and client coding (example? Figwheel?)
              And to another level â€“ Devcards
              Much more compact and concise, faster to work with (once youâ€™ve got used to it being denser)
              Java libraries rather than reimplementing everything from scratch
              JVM performance

              The community
              Again because the language is relatively new the community tends to be self-selecting for people interested in new languages. This effect will gradually wear off but means that a highly skilled and helpful community exists.


          </code></pre>

        </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
			history: true,
      margin: 0,
      center: false,

			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [
			{ src: 'plugin/notes/notes.js', async: true },
			{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
			]
			});
		</script>
	</body>
</html>
