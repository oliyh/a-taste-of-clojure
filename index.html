<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>A taste of Clojure</title>
    <meta name="author" content="Oliver Hine">
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-species-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

    <link rel="stylesheet" href="css/main.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section data-background-image="img/data-universe.jpg" style="">
          <br/><br/>
          <h1 class="title">A taste of Clojure</h1>
          <p style="color: black;">Oliver Hine</p>

          <div style="text-align: center; vertical-align: bottom; bottom: 0;">
            <a style="color: black" class="github" target="_blank" href="https://github.com/oliyh">
              <img class="logo" src="img/github-black.png"/>
              oliyh
            </a>
          </div>
          <aside class="notes">
            Hello, I'm Oliver Hine
            I'm going to talk about a functional lisp called Clojure and why you should be interested in it
          </aside>
        </section>

				<section data-background-image="img/about-me.jpg" style="">
          <h2>How my journey began</h2>
          <aside class="notes">
            I started my career as a Java developer by default - all the jobs going at the time were in Java and I'd picked up a bit at university although I had some self-taught knowledge of ASP, PHP, Javascript and the like.
            After moving through several teams, inheriting codebases of various ages and in various states I settled into a team that was "agile", did "TDD", "XP" and everything else where I learned vast amounts about proper software craftmanship and was very happy there for several years refactoring my way through tens of thousands of lines of carefully extracted interfaces, thoughtfully devised abstractions and meticulously complete stubs for mocked tests.
            We had some discussions about how Java's inheritance model didn't really let us express what we wanted to do, which at the time was something more akin to traits but I never seriously considered that rewriting the beast in a language with more features was possible.
            Fortunately a more enlightened team member introduced us to Clojure - this was around 2012 - and suddenly I had a totally different perspective on programming which I hope to share with you now.
          </aside>
        </section>

				<section data-background-image="" style="">
          <h2>Clojure</h2><br/><br/>
          <ul>
            <li>Functional</li>
            <li>Simple, concise</li>
            <li>Immutable data</li>
          </ul>
          <aside class="notes">
            These three points are the most important things to know about Clojure.
            Number one, it's functional, meaning functions are first class. You can declare and call functions, pass functions into other functions and return functions just as you would any other piece of data.
            Two is that it is simple and concise - there is very little syntax. Calling functions and data literals is pretty much all you need which makes it quick to learn and easy to read.
            Third is that data structures are immutable and highly efficient. This means that if I have a reference to some data I can guarantee that no one else can change it while I'm using it.
            I'll come back to these later to discuss in more detail.
            They are listed here because they're not the norm for programming languages, even though we could probably agree that they're good things.
            They are also basic, fundamental things. Clojure doesn't really have any clever, complicated high level abstractions that you have to learn,
            it just does some fundamental things better.




            In Clojure,
            Clojure is a simple and concise language. common with most lisps. This makes it quite quick to pick up once you get used to the prefix operators (because that's all there is to get used to). Clojure core is a small collection of very useful functions that operate on Clojure data structures.
            mutate it while I am using it. It's a simple concept that helps you write cleaner code and guarantees thread safety and looking back now it seems bonkers that it's not the default way all software operates because it removes an entire class of problems with virtually no drawbacks. It's akin to the way the managed memory runtime of the JVM removed a whole class of problems to do with manual memory management like buffer overflow bugs which are still afflicting us in the guises of Heartbleed and the recent Cloudflare leaks. It's hard to imagine why anyone would want to go back to manually managing their memory, and it's also hard to imagine why having mutable data structures is acceptable.
            If everything is thread safe by default you can scale your program across cores without thinking about it
            Java interop is there if you need it (in both directions â€“ can implement interfaces in clj and call from Java or call Java from clj)
            Can compile everything into a jar and just run it using java â€“jar
            Functions are first class. Functions can take functions and return functions
            Itâ€™s relatively new and designed by one person â€“ rather than being old, with a lot of legacy and backward compatability, designed by a committee
            Not actually tied to the JVM, although thatâ€™s the reference version. It also compiles to javascriptâ€¦
          </aside>
        </section>

				<section style="">
          <h2>Clojure ðŸ’– JVM</h2>
          <br/><br/><br/>
          (Clojure <span class="yellow">ðŸ’–</span> Javascript too)

          <aside class="notes">
            One thing missing from the previous slide is a practical and non-functional feature of Clojure which is that it compiles to and runs on the JVM. This was a pragmatic decision made both to improve Clojure's adoption appeal to people already familiar with the JVM and because of the high performance. In addition Clojure's ability to interop with Java code means that it benefits from all the libraries in the Java ecosystem.

            And one thing missing from this slide is that Clojure also compiles to Javascript which is now the world's most widespread runtime, and takes it to places that we never dreamed of before. Clojure can be used in browsers and on servers which makes it amazing for full stack development.
          </aside>
        </section>

				<section style="">
          <h2>Tooling</h2><br/>
          <ul>
            <li>Two build tools, lein and boot</li>
            <li>All major IDEs</li>
          </ul>
          <img src="img/xkcd-lisp.jpg"/>

          <aside class="notes">
            There are now two build tools, after many years with just one, that take care of all your dependencies, versioning, run profiles and everything else. They're both implemented in Clojure so understanding them, extending and changing them is quite easy.

            You can write Clojure with great editor support in Intellij, emacs, Eclipse and vim.
            Some tools which really help are paredit for emacs which abstracts away all the parentheses into operations on s-expressions. I know they can be intimidating at first but after getting used to them and the naked structure of lisp unfolds before you, the patterns and metapatterns dance and you swim in the purity of quantified conception of ideas manifest.
          </aside>
        </section>

				<section style="">
          <h2>REPL</h2><br/>

          <aside class="notes">
              The REPL
              Live evaluate code in your IDE
              Changes to your code can be hotloaded into your REPL
              Encourages exploration and less reliance on the test scaffolding we might otherwise build for basic functionality
              Do a bit of live coding â€“ some big hairy bit of data in a csv file, perhaps, read it out and parse it and ask questions of it
          </aside>
        </section>


				<section>
          <pre><code class="hljs" data-trim>
              State â€“ when you need it
              Carefully managed using atoms which are thread safe

              The community
              Again because the language is relatively new the community tends to be self-selecting for people interested in new languages. This effect will gradually wear off but means that a highly skilled and helpful community exists.

              What does all this mean?
              The net effect of not having to worry about constructing a clever and complicated type hierarchy of abstract concepts
              Become much closer to the data â€“ it becomes tangible, you can inspect it and play with it, itâ€™s not hidden away in some OO model
              Functions always return the same value given the same inputs â€“ removes a whole category of bugs (and the hardest bugs to track down as well â€“ heisenbugs)
              Unlikely to have threading bugs as well, also one of the harder kind of bugs to solve
              Full front-to-back services in the same language â€“ amazing for the developer

              How does it work without types?
              Can validate data using spec and schema at the edges of the system, leaving only happy path code inside
              Can write generative tests using these tools to test all permutations
              Linters can catch a lot of mistakes
              You tend to just deal with the primitive data types which tend to be much more compact anyway â€“ you know what sort of data you are dealing with
              You tend to write tests using real data, because itâ€™s just data that you can pull out of real systems and use immediately (rather than it being embedded in objects and abstractions which are hard to reconstruct in your test environment)
              What is the right thing to test? (comedy test the right thing gif here) - the answer is everything, and having a data-oriented language helps describe and realise this

              Whatâ€™s cool?
              Live server and client coding (example? Figwheel?)
              And to another level â€“ Devcards
              Much more compact and concise, faster to work with (once youâ€™ve got used to it being denser)
              Java libraries rather than reimplementing everything from scratch
              JVM performance
          </code></pre>

        </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
			history: true,
      margin: 0,
      center: false,

			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [
			{ src: 'plugin/notes/notes.js', async: true },
			{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
			]
			});
		</script>
	</body>
</html>
